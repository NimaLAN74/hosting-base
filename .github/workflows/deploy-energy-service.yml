name: Deploy Energy Service to Production

on:
  push:
    branches:
      - master
      - main
    paths:
      - 'lianel/dc/energy-service/**'
      - 'lianel/dc/docker-compose.backend.yaml'
      - 'lianel/dc/docker-compose.yaml'
      - '.github/workflows/deploy-energy-service.yml'
  workflow_dispatch:  # Allow manual trigger

env:
  REGISTRY: ghcr.io

jobs:
  build-and-deploy:
    name: Build and Deploy Energy Service
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set lowercase image name
        id: image-name
        run: |
          # Lowercase the repository name immediately to fix case sensitivity issues
          IMAGE_NAME_LC=$(echo "${{ github.repository }}/lianel-energy-service" | tr '[:upper:]' '[:lower:]')
          echo "IMAGE_NAME_LC=${IMAGE_NAME_LC}" >> $GITHUB_ENV
          echo "image_name=${IMAGE_NAME_LC}" >> $GITHUB_OUTPUT
          echo "‚úÖ Image name set to: ${IMAGE_NAME_LC}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.image-name.outputs.image_name }}
          tags: |
            # Only keep latest tag to save storage (removed branch and sha tags)
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./lianel/dc/energy-service
          file: ./lianel/dc/energy-service/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Make package public automatically
        if: success()
        run: |
          PACKAGE_NAME="${{ steps.image-name.outputs.image_name }}"
          echo "Making package public: $PACKAGE_NAME"
          
          # URL encode the package name (replace / with %2F)
          PACKAGE_NAME_ENCODED=$(echo "$PACKAGE_NAME" | sed 's/\//%2F/g')
          echo "Encoded package name: $PACKAGE_NAME_ENCODED"
          
          # Use GitHub API to make package public
          # Try user endpoint first (for personal accounts)
          if gh api -X PATCH "/user/packages/container/${PACKAGE_NAME_ENCODED}" -f visibility=public 2>&1; then
            echo "‚úÖ Package made public via user endpoint"
          else
            echo "‚ö†Ô∏è  User endpoint failed, trying org endpoint..."
            # Try org endpoint (for organization accounts)
            ORG_NAME=$(echo "$PACKAGE_NAME" | cut -d'/' -f1)
            PACKAGE_PATH=$(echo "$PACKAGE_NAME" | cut -d'/' -f2-)
            PACKAGE_PATH_ENCODED=$(echo "$PACKAGE_PATH" | sed 's/\//%2F/g')
            if gh api -X PATCH "/orgs/${ORG_NAME}/packages/container/${PACKAGE_PATH_ENCODED}" -f visibility=public 2>&1; then
              echo "‚úÖ Package made public via org endpoint"
            else
              echo "‚ö†Ô∏è  Warning: Failed to make package public automatically"
              echo "üí° Please make it public manually: https://github.com/NimaLAN74?tab=packages"
              echo "   Package: $PACKAGE_NAME"
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate Secrets
        run: |
          if [ -z "${{ secrets.REMOTE_HOST }}" ]; then
            echo "‚ùå Error: REMOTE_HOST secret is not set"
            echo "Please add REMOTE_HOST secret in repository settings"
            exit 1
          fi
          if [ -z "${{ secrets.REMOTE_USER }}" ]; then
            echo "‚ùå Error: REMOTE_USER secret is not set"
            echo "Please add REMOTE_USER secret in repository settings"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå Error: SSH_PRIVATE_KEY secret is not set"
            echo "Please add SSH_PRIVATE_KEY secret in repository settings"
            exit 1
          fi
          echo "‚úÖ All required secrets are configured"

      - name: Setup SSH Key
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write SSH key - handle multiline properly
          printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Verify key file exists and has content
          if [ ! -s ~/.ssh/deploy_key ]; then
            echo "‚ùå Error: SSH key file is empty or missing"
            exit 1
          fi
          
          # Check file size (should be at least 100 bytes for a valid key)
          KEY_SIZE=$(wc -c < ~/.ssh/deploy_key)
          if [ "$KEY_SIZE" -lt 100 ]; then
            echo "‚ùå Error: SSH key file is too small ($KEY_SIZE bytes)"
            exit 1
          fi
          
          # Verify key format (must start with -----BEGIN)
          FIRST_LINE=$(head -1 ~/.ssh/deploy_key | tr -d '\r\n' | tr -d '[:space:]')
          if [[ ! "$FIRST_LINE" =~ ^-----BEGIN ]]; then
            echo "‚ùå Error: SSH key format is incorrect"
            exit 1
          fi
          
          if [ -n "$REMOTE_HOST" ]; then
            ssh-keyscan -H "$REMOTE_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true
          fi
          
          echo "‚úÖ SSH key ready"

      - name: Create Deployment Script on Remote Host
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
        run: |
          # Create script using printf to avoid YAML heredoc parsing issues
          printf '%s\n' \
            '#!/bin/bash' \
            'set -euo pipefail' \
            '' \
            'IMAGE_TAG="$1"' \
            'SERVICE_NAME="energy-service"' \
            'LOCAL_TAG="lianel-energy-service:latest"' \
            'CONTAINER_NAME="lianel-energy-service"' \
            '' \
            'echo "=== Deploying Energy Service ==="' \
            'echo "Image: $IMAGE_TAG"' \
            '' \
            'cd /root/lianel/dc' \
            '' \
            'docker logout ghcr.io 2>/dev/null || true' \
            '' \
            'echo "Pulling image..."' \
            'if docker pull "$IMAGE_TAG" 2>&1; then' \
            '  echo "‚úÖ Image pulled successfully (public package)"' \
            'else' \
            '  PULL_EXIT=$?' \
            '  echo "‚ö†Ô∏è  Pull failed (exit code: $PULL_EXIT), trying with authentication..."' \
            '  if [ -n "${GITHUB_TOKEN:-}" ] && [ -n "${GITHUB_ACTOR:-}" ]; then' \
            '    echo "Authenticating with GitHub..."' \
            '    echo "$GITHUB_TOKEN" | docker login ghcr.io -u "$GITHUB_ACTOR" --password-stdin 2>&1 || true' \
            '    if docker pull "$IMAGE_TAG" 2>&1; then' \
            '      echo "‚úÖ Image pulled successfully with authentication"' \
            '    else' \
            '      echo "‚ùå Error: Failed to pull image even with authentication"' \
            '      exit 1' \
            '    fi' \
            '  else' \
            '    echo "‚ùå Error: Failed to pull image and no authentication available"' \
            '    exit 1' \
            '  fi' \
            'fi' \
            '' \
            'echo "Tagging image..."' \
            'docker tag "$IMAGE_TAG" "$LOCAL_TAG"' \
            '' \
            'echo "Restarting container..."' \
            'docker stop $CONTAINER_NAME 2>/dev/null || true' \
            'docker rm $CONTAINER_NAME 2>/dev/null || true' \
            '' \
            'docker compose -f docker-compose.infra.yaml -f docker-compose.backend.yaml up -d $SERVICE_NAME' \
            '' \
            'sleep 3' \
            '' \
            'if docker ps --format "{{.Names}}" | grep -q "^lianel-energy-service$"; then' \
            '  echo "‚úÖ Container is running"' \
            '  docker ps --filter "name=lianel-energy-service" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"' \
            'else' \
            '  echo "‚ùå Container failed to start"' \
            '  docker logs lianel-energy-service --tail 50' \
            '  exit 1' \
            'fi' \
            '' \
            'echo "‚úÖ Energy Service deployment complete!"' \
            > /tmp/deploy-energy-service.sh
          
          chmod +x /tmp/deploy-energy-service.sh
          
          # Transfer script to remote host
          scp -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -P ${REMOTE_PORT} \
            /tmp/deploy-energy-service.sh \
            ${REMOTE_USER}@${REMOTE_HOST}:/root/deploy-energy-service.sh
          
          echo "‚úÖ Deployment script created on remote host"

      - name: Deploy to Remote Host
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          IMAGE_TAG="${{ env.REGISTRY }}/${{ steps.image-name.outputs.image_name }}:latest"
          echo "Deploying: $IMAGE_TAG"
          
          # Execute deployment
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -p ${REMOTE_PORT} \
            ${REMOTE_USER}@${REMOTE_HOST} \
            "GITHUB_TOKEN='${GITHUB_TOKEN}' GITHUB_ACTOR='${{ github.actor }}' /root/deploy-energy-service.sh '$IMAGE_TAG'"

      - name: Deployment Summary
        run: |
          echo "## üöÄ Energy Service Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: \`${{ env.REGISTRY }}/${{ steps.image-name.outputs.image_name }}:latest\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Platform**: linux/amd64" >> $GITHUB_STEP_SUMMARY
          echo "- **Language**: Rust" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed to**: \`${{ secrets.REMOTE_HOST }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Storage Optimized**: ‚úÖ No artifacts, direct registry pull" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ‚úÖ Success" >> $GITHUB_STEP_SUMMARY

