name: Deploy Frontend to Production

on:
  push:
    branches:
      - master
      - main
    paths:
      - 'lianel/dc/frontend/**'
      - 'lianel/dc/docker-compose.frontend.yaml'
      - 'lianel/dc/docker-compose.yaml'
      - 'lianel/dc/docker-compose.infra.yaml'
      - 'lianel/dc/scripts/deployment/deploy-frontend.sh'
      - 'lianel/dc/nginx/**'
      - '.github/workflows/deploy-frontend.yml'
  workflow_dispatch:  # Allow manual trigger

env:
  REGISTRY: ghcr.io

jobs:
  build-and-deploy:
    name: Build and Deploy Frontend
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Pipeline context (monitor run)
        run: |
          echo "## Pipeline context" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Run ID | \`${{ github.run_id }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Run URL | https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Branch | \`${{ github.ref_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Workflow | \`${{ github.workflow }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Actor | \`${{ github.actor }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | \`${{ github.event_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo ""
          echo "[Monitor] Run ${{ github.run_id }} | ${{ github.ref_name }} | ${{ github.workflow }}"

      - name: Set lowercase image name
        id: image-name
        run: |
          # Lowercase the repository name immediately to fix case sensitivity issues
          IMAGE_NAME_LC=$(echo "${{ github.repository }}/lianel-frontend" | tr '[:upper:]' '[:lower:]')
          echo "IMAGE_NAME_LC=${IMAGE_NAME_LC}" >> $GITHUB_ENV
          echo "image_name=${IMAGE_NAME_LC}" >> $GITHUB_OUTPUT
          echo "‚úÖ Image name set to: ${IMAGE_NAME_LC}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.image-name.outputs.image_name }}
          tags: |
            # Only keep latest tag to save storage (removed branch and sha tags)
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./lianel/dc/frontend
          file: ./lianel/dc/frontend/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            REACT_APP_KEYCLOAK_URL=https://www.lianel.se/auth
            REACT_APP_KEYCLOAK_REALM=lianel
            REACT_APP_KEYCLOAK_CLIENT_ID=frontend-client
            REACT_APP_GRAFANA_URL=https://monitoring.lianel.se
            REACT_APP_AIRFLOW_URL=https://airflow.lianel.se
            REACT_APP_FRONTEND_URL=https://www.lianel.se
            REACT_APP_DOMAIN_MAIN=www.lianel.se
            REACT_APP_DOMAIN_ALT=lianel.se
            REACT_APP_DOMAIN_AUTH=auth.lianel.se
            REACT_APP_DOMAIN_MONITORING=monitoring.lianel.se
            REACT_APP_DOMAIN_AIRFLOW=airflow.lianel.se
            REACT_APP_OAUTH2_PROXY_CLIENT_ID=oauth2-proxy

      - name: Make package public automatically
        if: success()
        run: |
          PACKAGE_NAME="${{ steps.image-name.outputs.image_name }}"
          echo "Making package public: $PACKAGE_NAME"
          
          # URL encode the package name (replace / with %2F)
          PACKAGE_NAME_ENCODED=$(echo "$PACKAGE_NAME" | sed 's/\//%2F/g')
          echo "Encoded package name: $PACKAGE_NAME_ENCODED"
          
          # Use GitHub API to make package public
          # Try user endpoint first (for personal accounts)
          if gh api -X PATCH "/user/packages/container/${PACKAGE_NAME_ENCODED}" -f visibility=public 2>&1; then
            echo "‚úÖ Package made public via user endpoint"
          else
            echo "‚ö†Ô∏è  User endpoint failed, trying org endpoint..."
            # Try org endpoint (for organization accounts)
            ORG_NAME=$(echo "$PACKAGE_NAME" | cut -d'/' -f1)
            PACKAGE_PATH=$(echo "$PACKAGE_NAME" | cut -d'/' -f2-)
            PACKAGE_PATH_ENCODED=$(echo "$PACKAGE_PATH" | sed 's/\//%2F/g')
            if gh api -X PATCH "/orgs/${ORG_NAME}/packages/container/${PACKAGE_PATH_ENCODED}" -f visibility=public 2>&1; then
              echo "‚úÖ Package made public via org endpoint"
            else
              echo "‚ö†Ô∏è  Warning: Failed to make package public automatically"
              echo "üí° Please make it public manually: https://github.com/NimaLAN74?tab=packages"
              echo "   Package: $PACKAGE_NAME"
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # REMOVED: Artifact upload to save storage (image is already in registry)
      # Image will be pulled directly from registry on remote host

      - name: Validate Secrets
        run: |
          if [ -z "${{ secrets.REMOTE_HOST }}" ]; then
            echo "‚ùå Error: REMOTE_HOST secret is not set"
            echo "Please add REMOTE_HOST secret in repository settings"
            exit 1
          fi
          if [ -z "${{ secrets.REMOTE_USER }}" ]; then
            echo "‚ùå Error: REMOTE_USER secret is not set"
            echo "Please add REMOTE_USER secret in repository settings"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå Error: SSH_PRIVATE_KEY secret is not set"
            echo "Please add SSH_PRIVATE_KEY secret in repository settings"
            exit 1
          fi
          echo "‚úÖ All required secrets are configured"

      - name: Setup SSH Key
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write SSH key - handle multiline properly
          # Use printf to ensure proper newline handling
          printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Verify key file exists and has content
          if [ ! -s ~/.ssh/deploy_key ]; then
            echo "‚ùå Error: SSH key file is empty or missing"
            echo "Please check that SSH_PRIVATE_KEY secret contains the complete private key"
            exit 1
          fi
          
          # Check file size (should be at least 100 bytes for a valid key)
          KEY_SIZE=$(wc -c < ~/.ssh/deploy_key)
          if [ "$KEY_SIZE" -lt 100 ]; then
            echo "‚ùå Error: SSH key file is too small ($KEY_SIZE bytes)"
            echo "Expected at least 100 bytes for a valid private key"
            echo "First 100 chars: $(head -c 100 ~/.ssh/deploy_key)"
            exit 1
          fi
          
          # Verify key format (must start with -----BEGIN)
          FIRST_LINE=$(head -1 ~/.ssh/deploy_key | tr -d '\r\n' | tr -d '[:space:]')
          if [[ ! "$FIRST_LINE" =~ ^-----BEGIN ]]; then
            echo "‚ùå Error: SSH key format is incorrect"
            echo "First line: '$FIRST_LINE'"
            echo ""
            echo "The SSH_PRIVATE_KEY secret should contain:"
            echo "  - Complete private key starting with: -----BEGIN OPENSSH PRIVATE KEY-----"
            echo "  - Ending with: -----END OPENSSH PRIVATE KEY-----"
            echo "  - All lines in between"
            echo ""
            echo "Current key file preview (first 5 lines):"
            head -5 ~/.ssh/deploy_key
            echo ""
            echo "If you see 'ssh-ed25519' as text, that's wrong - that's the key type, not the key itself"
            exit 1
          fi
          
          # Verify key ends with -----END
          LAST_LINE=$(tail -1 ~/.ssh/deploy_key | tr -d '\r\n' | tr -d '[:space:]')
          if [[ ! "$LAST_LINE" =~ ^-----END ]]; then
            echo "‚ö†Ô∏è  Warning: SSH key might not end correctly"
            echo "Last line: '$LAST_LINE'"
          fi
          
          # Check for common mistakes
          if grep -q "^ssh-ed25519 " ~/.ssh/deploy_key; then
            echo "‚ùå Error: SSH key contains 'ssh-ed25519' as text"
            echo "This looks like a public key, not a private key!"
            echo "The SSH_PRIVATE_KEY secret should contain the PRIVATE key, not the public key"
            echo ""
            echo "To get the private key, run: cat ~/.ssh/id_ed25519_host"
            echo "The private key starts with: -----BEGIN OPENSSH PRIVATE KEY-----"
            exit 1
          fi
          
          # Test key format with ssh-keygen (if available)
          if command -v ssh-keygen >/dev/null 2>&1; then
            if ! ssh-keygen -l -f ~/.ssh/deploy_key >/dev/null 2>&1; then
              echo "‚ö†Ô∏è  Warning: ssh-keygen validation failed (key might be invalid)"
              echo "But continuing anyway..."
            fi
          fi
          
          if [ -n "$REMOTE_HOST" ]; then
            ssh-keyscan -H "$REMOTE_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true
          fi
          
          echo "‚úÖ SSH key ready"
          echo "Key file size: $KEY_SIZE bytes"
          echo "Key file lines: $(wc -l < ~/.ssh/deploy_key) lines"

      - name: Test SSH connectivity (preflight)
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
        run: |
          echo "[Monitor] Testing SSH to ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_PORT}..."
          if ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o ConnectTimeout=15 \
            -p "${REMOTE_PORT}" \
            "${REMOTE_USER}@${REMOTE_HOST}" \
            "echo 'SSH OK'; hostname; whoami; echo 'Target user can write to /root:' \$([ -w /root ] && echo yes || echo no)"; then
            echo "‚úÖ SSH preflight passed"
          else
            echo "‚ùå SSH preflight failed ‚Äî fix connectivity before Copy step"
            echo "Check: REMOTE_HOST, REMOTE_USER, REMOTE_PORT, SSH key, firewall, sshd on host"
            exit 1
          fi

      - name: Copy Deployment Script to Remote Host
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
        run: |
          set -e
          echo "[Monitor] Copy step ‚Äî REMOTE_HOST=$REMOTE_HOST REMOTE_USER=$REMOTE_USER REMOTE_PORT=$REMOTE_PORT"
          SCRIPT_PATH="lianel/dc/scripts/deployment/deploy-frontend.sh"
          if [ ! -f "$SCRIPT_PATH" ]; then
            echo "‚ùå Local script missing: $SCRIPT_PATH"
            exit 1
          fi
          echo "Running scp..."
          scp -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o ConnectTimeout=15 \
            -P "${REMOTE_PORT}" \
            "$SCRIPT_PATH" \
            "${REMOTE_USER}@${REMOTE_HOST}:/root/deploy-frontend.sh" || { echo "‚ùå scp failed (exit $?)"; exit 1; }
          echo "‚úÖ scp OK"
          echo "Running ssh chmod..."
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -p "${REMOTE_PORT}" \
            "${REMOTE_USER}@${REMOTE_HOST}" \
            "chmod +x /root/deploy-frontend.sh && test -x /root/deploy-frontend.sh && echo 'script executable'" || { echo "‚ùå ssh chmod failed (exit $?)"; exit 1; }
          echo "‚úÖ Deployment script copied and made executable"

      - name: Deploy to Remote Host
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          IMAGE_TAG="${{ env.REGISTRY }}/${{ steps.image-name.outputs.image_name }}:latest"
          echo "Deploying: $IMAGE_TAG"
          
          # Simple SSH command - just call the deployment script
          # Note: Packages are public, but we pass GITHUB_TOKEN in case auth is needed
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -p ${REMOTE_PORT} \
            ${REMOTE_USER}@${REMOTE_HOST} \
            "GITHUB_TOKEN='${GITHUB_TOKEN}' GITHUB_ACTOR='${{ github.actor }}' /root/deploy-frontend.sh '$IMAGE_TAG'"

      - name: Sync nginx config to remote
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
        run: |
          echo "Syncing nginx config to remote..."
          scp -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -P ${REMOTE_PORT} \
            lianel/dc/nginx/config/nginx.conf \
            ${REMOTE_USER}@${REMOTE_HOST}:/tmp/nginx.conf
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -p ${REMOTE_PORT} \
            ${REMOTE_USER}@${REMOTE_HOST} \
            "mkdir -p /root/lianel/dc/nginx/config /root/hosting-base/lianel/dc/nginx/config 2>/dev/null; for d in /root/lianel/dc/nginx/config /root/hosting-base/lianel/dc/nginx/config; do [ -d \"\$d\" ] && cp /tmp/nginx.conf \"\$d/\" && echo \"Updated \$d\"; done; docker exec nginx-proxy nginx -t 2>/dev/null && docker exec nginx-proxy nginx -s reload 2>/dev/null && echo '‚úÖ Nginx reloaded' || echo '‚ö†Ô∏è Nginx reload skipped (container or path may differ)'"
          echo "‚úÖ Nginx config synced"

      - name: Apply Keycloak redirect fix on remote (ensure keycloak+nginx on same network)
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
        run: |
          echo "Syncing docker-compose.infra.yaml + nginx.conf, then starting full infra stack (keycloak + nginx) so both are on lianel-network..."
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -P "${REMOTE_PORT}" \
            lianel/dc/docker-compose.infra.yaml "${REMOTE_USER}@${REMOTE_HOST}:/tmp/docker-compose.infra.yaml"
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -P "${REMOTE_PORT}" \
            lianel/dc/nginx/config/nginx.conf "${REMOTE_USER}@${REMOTE_HOST}:/tmp/nginx.conf"
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -p "${REMOTE_PORT}" \
            ${REMOTE_USER}@${REMOTE_HOST} \
            "for d in /root/lianel/dc /root/hosting-base/lianel/dc; do [ -d \"\$d\" ] && cp /tmp/docker-compose.infra.yaml \"\$d/\" && mkdir -p \"\$d/nginx/config\" && cp /tmp/nginx.conf \"\$d/nginx/config/\" && echo \"Updated \$d\"; done; DC=\$( [ -f /root/lianel/dc/docker-compose.infra.yaml ] && echo /root/lianel/dc || echo /root/hosting-base/lianel/dc ); cd \"\$DC\" && docker compose -f docker-compose.infra.yaml up -d 2>&1 || docker-compose -f docker-compose.infra.yaml up -d 2>&1; echo 'Waiting for Keycloak...'; for i in 1 2 3 4 5 6; do docker ps --filter name=keycloak --filter status=running -q | grep -q . && break; sleep 5; done; sleep 15; docker ps --filter name=keycloak; docker ps --filter name=nginx-proxy; docker exec nginx-proxy nginx -t 2>/dev/null && docker exec nginx-proxy nginx -s reload 2>/dev/null && echo '‚úÖ Infra stack (keycloak+nginx) on lianel-network' || echo '‚ö†Ô∏è Check keycloak/nginx on server'"
          echo "‚úÖ Keycloak+nginx infra applied on remote"

      - name: Run Keycloak redirect scripts on remote (frontendUrl + frontend-client rootUrl)
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
          KEYCLOAK_ADMIN_PASSWORD: ${{ secrets.KEYCLOAK_ADMIN_PASSWORD }}
        run: |
          echo "Copying Keycloak scripts to remote..."
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -P "${REMOTE_PORT}" \
            lianel/dc/scripts/keycloak-setup/fix-keycloak-https.sh \
            lianel/dc/scripts/keycloak-setup/update-keycloak-frontend-client.sh \
            ${REMOTE_USER}@${REMOTE_HOST}:/tmp/
          echo "Running Keycloak redirect scripts on remote (realm frontendUrl + frontend-client rootUrl)..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -p "${REMOTE_PORT}" \
            ${REMOTE_USER}@${REMOTE_HOST} \
            "export KEYCLOAK_ADMIN_PASSWORD='${KEYCLOAK_ADMIN_PASSWORD}'; export APP_FRONTEND_URL=https://www.lianel.se; cd /root/lianel/dc 2>/dev/null || cd /root/hosting-base/lianel/dc; bash /tmp/fix-keycloak-https.sh 2>&1; bash /tmp/update-keycloak-frontend-client.sh 2>&1"
        continue-on-error: true

      - name: Verify deployment (main page + auth URL)
        run: |
          URL="${FRONTEND_URL:-https://www.lianel.se}"
          AUTH_URL="${URL}/auth/realms/lianel/protocol/openid-connect/auth?client_id=frontend-client&redirect_uri=${URL}/&response_type=code&scope=openid&prompt=login"
          echo "[Monitor] Checking main page: $URL"
          HTTP_MAIN=$(curl -sSf -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 "$URL/" 2>/dev/null || echo "000")
          echo "[Monitor] Checking auth URL (must not be 502): $URL/auth/..."
          HTTP_AUTH=$(curl -sSf -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 "$AUTH_URL" 2>/dev/null || echo "000")
          if [ -z "$HTTP_MAIN" ] || [ "$HTTP_MAIN" = "000" ]; then
            echo "‚ùå Main page unreachable"
            echo "Live check: ‚ùå main unreachable" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          if [ "$HTTP_MAIN" -ge 200 ] && [ "$HTTP_MAIN" -lt 400 ]; then
            echo "‚úÖ Main page: HTTP $HTTP_MAIN"
          else
            echo "‚ùå Main page: HTTP $HTTP_MAIN (expected 2xx/3xx)"
            echo "Live check: ‚ùå main $HTTP_MAIN" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          if [ "$HTTP_AUTH" = "502" ]; then
            echo "‚ùå Auth URL returned 502 ‚Äî nginx cannot reach Keycloak. Ensure keycloak and nginx are on same Docker network (lianel-network). See docs/fixes/LOGIN-ISSUE-ANALYSIS.md and LOGIN-REDIRECT-ANALYSIS.md runbook."
            echo "Live check: ‚ùå auth 502 (Keycloak unreachable)" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          if [ "$HTTP_AUTH" -ge 200 ] && [ "$HTTP_AUTH" -lt 500 ]; then
            echo "‚úÖ Auth URL: HTTP $HTTP_AUTH (login page reachable)"
            echo "Live check: ‚úÖ main $HTTP_MAIN, auth $HTTP_AUTH" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è Auth URL: HTTP $HTTP_AUTH (non-502)"
            echo "Live check: ‚úÖ main $HTTP_MAIN, auth $HTTP_AUTH" >> $GITHUB_STEP_SUMMARY
          fi
        env:
          FRONTEND_URL: ${{ vars.FRONTEND_URL || 'https://www.lianel.se' }}

      - name: Deployment Summary
        run: |
          echo "## üöÄ Frontend Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: \`${{ env.REGISTRY }}/${{ steps.image-name.outputs.image_name }}:latest\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Platform**: linux/amd64" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed to**: \`${{ secrets.REMOTE_HOST }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Storage Optimized**: ‚úÖ No artifacts, direct registry pull" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ‚úÖ Success" >> $GITHUB_STEP_SUMMARY

