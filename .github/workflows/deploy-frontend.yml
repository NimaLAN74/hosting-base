name: Deploy Frontend to Production

on:
  push:
    branches:
      - master
      - main
    paths:
      - 'lianel/dc/frontend/**'
      - 'lianel/dc/docker-compose.frontend.yaml'
      - 'lianel/dc/docker-compose.yaml'
      - '.github/workflows/deploy-frontend.yml'
  workflow_dispatch:  # Allow manual trigger

env:
  REGISTRY: ghcr.io

jobs:
  build-and-deploy:
    name: Build and Deploy Frontend
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set lowercase image name
        id: image-name
        run: |
          # Lowercase the repository name immediately to fix case sensitivity issues
          IMAGE_NAME_LC=$(echo "${{ github.repository }}/lianel-frontend" | tr '[:upper:]' '[:lower:]')
          echo "IMAGE_NAME_LC=${IMAGE_NAME_LC}" >> $GITHUB_ENV
          echo "image_name=${IMAGE_NAME_LC}" >> $GITHUB_OUTPUT
          echo "‚úÖ Image name set to: ${IMAGE_NAME_LC}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.image-name.outputs.image_name }}
          tags: |
            # Only keep latest tag to save storage (removed branch and sha tags)
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./lianel/dc/frontend
          file: ./lianel/dc/frontend/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Make package public automatically
        if: success()
        run: |
          PACKAGE_NAME="${{ steps.image-name.outputs.image_name }}"
          echo "Making package public: $PACKAGE_NAME"
          
          # Use GitHub API to make package public
          gh api \
            -X PATCH \
            "/user/packages/container/${PACKAGE_NAME}" \
            -f visibility=public \
            || echo "‚ö†Ô∏è  Note: Package might already be public or API call failed (this is OK)"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # REMOVED: Artifact upload to save storage (image is already in registry)
      # Image will be pulled directly from registry on remote host

      - name: Validate Secrets
        run: |
          if [ -z "${{ secrets.REMOTE_HOST }}" ]; then
            echo "‚ùå Error: REMOTE_HOST secret is not set"
            echo "Please add REMOTE_HOST secret in repository settings"
            exit 1
          fi
          if [ -z "${{ secrets.REMOTE_USER }}" ]; then
            echo "‚ùå Error: REMOTE_USER secret is not set"
            echo "Please add REMOTE_USER secret in repository settings"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå Error: SSH_PRIVATE_KEY secret is not set"
            echo "Please add SSH_PRIVATE_KEY secret in repository settings"
            exit 1
          fi
          echo "‚úÖ All required secrets are configured"

      - name: Setup SSH Key
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write SSH key properly - use printf to handle multiline correctly
          # Remove any potential BOM or extra whitespace
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Verify key file exists and has content
          if [ ! -s ~/.ssh/deploy_key ]; then
            echo "‚ùå Error: SSH key file is empty or missing"
            exit 1
          fi
          
          # Verify key format (should start with -----BEGIN)
          FIRST_LINE=$(head -1 ~/.ssh/deploy_key | tr -d '\r\n')
          if [[ ! "$FIRST_LINE" =~ ^-----BEGIN ]]; then
            echo "‚ùå Error: SSH key format is incorrect"
            echo "First line: '$FIRST_LINE'"
            echo "First 50 chars: $(head -c 50 ~/.ssh/deploy_key)"
            echo "Key file content preview:"
            head -5 ~/.ssh/deploy_key
            exit 1
          fi
          
          # Verify key ends with -----END
          LAST_LINE=$(tail -1 ~/.ssh/deploy_key | tr -d '\r\n')
          if [[ ! "$LAST_LINE" =~ ^-----END ]]; then
            echo "‚ö†Ô∏è  Warning: SSH key might not end correctly"
            echo "Last line: '$LAST_LINE'"
          fi
          
          if [ -n "$REMOTE_HOST" ]; then
            ssh-keyscan -H "$REMOTE_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true
          fi
          echo "‚úÖ SSH key setup complete"
          echo "Key file size: $(wc -c < ~/.ssh/deploy_key) bytes"
          echo "Key file lines: $(wc -l < ~/.ssh/deploy_key) lines"

      - name: Test SSH Connection
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
        run: |
          # Verify key file before using
          if [ ! -f ~/.ssh/deploy_key ]; then
            echo "‚ùå Error: SSH key file not found"
            exit 1
          fi
          
          # Test SSH connection with verbose output for debugging
          echo "Testing SSH connection to ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_PORT}"
          ssh -v -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} "echo '‚úÖ SSH connection successful'" 2>&1 | head -20 || {
            echo "‚ùå SSH connection failed"
            echo "Key file check:"
            ls -la ~/.ssh/deploy_key
            echo "First few lines of key:"
            head -3 ~/.ssh/deploy_key
            exit 1
          }

      - name: Deploy to Remote Host
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          IMAGE_TAG_FULL="${{ env.REGISTRY }}/${{ steps.image-name.outputs.image_name }}:latest"
          echo "üîç Debug: Constructed image tag: $IMAGE_TAG_FULL"
          echo "üîç Debug: Registry: ${{ env.REGISTRY }}"
          echo "üîç Debug: Image name: ${{ steps.image-name.outputs.image_name }}"
          # Verify SSH key before connecting
          if [ ! -f ~/.ssh/deploy_key ]; then
            echo "‚ùå Error: SSH key file not found"
            exit 1
          fi
          
          echo "Connecting to ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_PORT}"
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} bash -s << EOF
            set -euxo pipefail
            IMAGE_TAG_FULL="${IMAGE_TAG_FULL}"
            echo "üîç Debug: Received image tag on remote: $IMAGE_TAG_FULL"
            GITHUB_TOKEN="${GITHUB_TOKEN}"
            echo "=== Deploying frontend from registry ==="
            cd /root/lianel/dc
            
            # Pull image directly from registry
            # If package is private, login first (optional - only if GITHUB_PAT secret exists)
            echo "üì• Pulling image from registry..."
            IMAGE_TAG="${IMAGE_TAG_FULL}"
            
            # Debug: Show image tag details
            echo "Image tag to pull: $IMAGE_TAG"
            echo "Image tag length: ${#IMAGE_TAG}"
            echo "Image tag components:"
            echo "  - Full: $IMAGE_TAG"
            echo "  - Registry: $(echo $IMAGE_TAG | cut -d'/' -f1)"
            echo "  - Path: $(echo $IMAGE_TAG | cut -d'/' -f2-)"
            
            # Basic validation (check for required components)
            if [[ -z "$IMAGE_TAG" ]] || [[ ! "$IMAGE_TAG" =~ : ]]; then
              echo "‚ùå Error: Invalid image tag format: $IMAGE_TAG"
              echo "Expected format: registry/owner/repo/image:tag"
              exit 1
            fi
            
            # Try to pull (works if package is public)
            echo "Attempting to pull: $IMAGE_TAG"
            if docker pull "$IMAGE_TAG" 2>&1; then
              echo "‚úÖ Image pulled successfully"
              docker images | grep "$(echo $IMAGE_TAG | cut -d: -f1)" || true
            else
              PULL_EXIT_CODE=$?
              echo "‚ö†Ô∏è  Pull failed (exit code: $PULL_EXIT_CODE), package is private - authenticating..."
              # Use GITHUB_TOKEN for authentication (automatically available in workflows)
              if [ -n "$GITHUB_TOKEN" ]; then
                echo "Using GITHUB_TOKEN for authentication..."
                echo "$GITHUB_TOKEN" | docker login ghcr.io -u ${{ github.actor }} --password-stdin 2>&1
                LOGIN_EXIT=$?
                if [ $LOGIN_EXIT -ne 0 ]; then
                  echo "‚ö†Ô∏è  Warning: Docker login failed (exit code: $LOGIN_EXIT)"
                  echo "This might be a permissions issue. Check workflow permissions include 'packages: write'"
                else
                  echo "‚úÖ Docker login successful"
                fi
                if docker pull "$IMAGE_TAG" 2>&1; then
                  echo "‚úÖ Image pulled successfully with authentication"
                  docker images | grep "$(echo $IMAGE_TAG | cut -d: -f1)" || true
                else
                  echo "‚ùå Error: Failed to pull image even with authentication"
                  echo "Image: $IMAGE_TAG"
                  echo "üí° Make package public: Settings ‚Üí Packages ‚Üí Package name ‚Üí Package settings ‚Üí Change visibility"
                  exit 1
                fi
              else
                echo "‚ùå Error: Failed to pull image (package is private and no token available)"
                echo "Image: $IMAGE_TAG"
                echo "üí° Solutions:"
                echo "   1. Make package public: Settings ‚Üí Packages ‚Üí [package] ‚Üí Package settings ‚Üí Change visibility"
                echo "   2. Or ensure GITHUB_TOKEN is available (should be automatic in workflows)"
                exit 1
              fi
            fi
            
            # Tag for local use
            echo "üè∑Ô∏è  Tagging image..."
            docker tag "$IMAGE_TAG" lianel-frontend:latest || {
              echo "‚ùå Error: Failed to tag image"
              exit 1
            }
            
            # Verify tag was created
            if ! docker images | grep -q "lianel-frontend.*latest"; then
              echo "‚ùå Error: Tag verification failed"
              docker images | grep frontend
              exit 1
            fi
            echo "‚úÖ Image tagged successfully"
            
            # Ensure network exists
            echo "üåê Ensuring network exists..."
            docker network create lianel-network 2>/dev/null || true
            if ! docker network inspect lianel-network >/dev/null 2>&1; then
              echo "‚ùå Error: Failed to create/verify network"
              exit 1
            fi
            echo "‚úÖ Network verified"
            
            # Stop and remove existing container
            echo "üõë Stopping existing container..."
            docker stop lianel-frontend 2>/dev/null || true
            docker rm lianel-frontend 2>/dev/null || true
            
            # Deploy using docker-compose.yaml (image-only, no build section)
            echo "üöÄ Deploying frontend container..."
            echo "Current directory: $(pwd)"
            echo "Available compose files:"
            ls -la docker-compose*.yaml 2>/dev/null || echo "No compose files found"
            
            # Use docker-compose.yaml which has image-only definition
            if [ -f docker-compose.yaml ]; then
              echo "Using docker-compose.yaml"
              if command -v docker-compose >/dev/null 2>&1; then
                docker-compose -f docker-compose.yaml up -d frontend 2>&1 || {
                  echo "‚ùå Error: docker-compose failed"
                  echo "Compose file validation:"
                  docker-compose -f docker-compose.yaml config 2>&1 || true
                  echo "Container status:"
                  docker ps -a | grep frontend || true
                  exit 1
                }
              else
                docker compose -f docker-compose.yaml up -d frontend 2>&1 || {
                  echo "‚ùå Error: docker compose failed"
                  echo "Compose file validation:"
                  docker compose -f docker-compose.yaml config 2>&1 || true
                  echo "Container status:"
                  docker ps -a | grep frontend || true
                  exit 1
                }
              fi
            else
              echo "‚ùå Error: docker-compose.yaml not found"
              echo "Files in current directory:"
              ls -la
              exit 1
            fi
            
            # Verify deployment
            echo "=== Verifying deployment ==="
            sleep 5
            if ! docker ps | grep -q lianel-frontend; then
              echo "‚ùå Error: Container not running"
              docker ps -a | grep frontend
              docker logs lianel-frontend --tail 50 || true
              exit 1
            fi
            echo "‚úÖ Container is running"
            
            # Health check
            echo "üè• Performing health check..."
            sleep 10  # Wait for service to start
            HTTP_CODE=$(curl -sk -o /dev/null -w "%{http_code}" https://lianel.se/ 2>/dev/null || echo "000")
            if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "302" ] && [ "$HTTP_CODE" != "401" ]; then
              echo "‚ö†Ô∏è  Warning: Health check returned HTTP $HTTP_CODE (expected 200, 302, or 401)"
              echo "Container logs:"
              docker logs lianel-frontend --tail 30
            else
              echo "‚úÖ Health check passed: HTTP $HTTP_CODE"
            fi
            
            # Clean up old images
            echo "=== Cleaning up ==="
            docker image prune -f
            
            echo "=== ‚úÖ Deployment successful ==="
          EOF

      - name: Deployment Summary
        run: |
          echo "## üöÄ Frontend Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: \`${{ env.REGISTRY }}/${{ steps.image-name.outputs.image_name }}:latest\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Platform**: linux/amd64" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed to**: \`${{ secrets.REMOTE_HOST }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Storage Optimized**: ‚úÖ No artifacts, direct registry pull" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ‚úÖ Success" >> $GITHUB_STEP_SUMMARY

