name: Deploy Comp AI Service to Production

on:
  push:
    branches:
      - master
      - main
    paths:
      - 'lianel/dc/comp-ai-service/**'
      - 'lianel/dc/database/migrations/**'
      - 'lianel/dc/scripts/deployment/run-comp-ai-migrations.sh'
      - 'lianel/dc/docker-compose.comp-ai.yaml'
      - 'lianel/dc/docker-compose.yaml'
      - '.github/workflows/deploy-comp-ai-service.yml'
      - '.github/scripts/watch-deploy-comp-ai.sh'
  workflow_dispatch:  # Allow manual trigger

env:
  REGISTRY: ghcr.io

jobs:
  build-and-deploy:
    name: Build and Deploy Comp AI Service
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U postgres"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set lowercase image name
        id: image-name
        run: |
          # Lowercase the repository name immediately to fix case sensitivity issues
          IMAGE_NAME_LC=$(echo "${{ github.repository }}/lianel-comp-ai-service" | tr '[:upper:]' '[:lower:]')
          echo "IMAGE_NAME_LC=${IMAGE_NAME_LC}" >> $GITHUB_ENV
          echo "image_name=${IMAGE_NAME_LC}" >> $GITHUB_OUTPUT
          echo "‚úÖ Image name set to: ${IMAGE_NAME_LC}"

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry and target
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: lianel/dc/comp-ai-service

      - name: Run comp_ai migrations
        env:
          DATABASE_URL: postgres://postgres:postgres@127.0.0.1:5432/postgres
        run: |
          set -e
          sudo apt-get update -qq && sudo apt-get install -y -qq postgresql-client
          echo "Waiting for Postgres..."
          for i in $(seq 1 30); do
            if PGPASSWORD=postgres psql -h 127.0.0.1 -U postgres -d postgres -c "SELECT 1" -q 2>/dev/null; then
              echo "Postgres ready"; break
            fi
            [ "$i" -eq 30 ] && { echo "Postgres did not become ready"; exit 1; }
            sleep 1
          done
          for f in lianel/dc/database/migrations/009_create_comp_ai_schema.sql \
                   lianel/dc/database/migrations/010_comp_ai_controls_evidence.sql \
                   lianel/dc/database/migrations/011_comp_ai_seed_soc2.sql; do
            echo "Running $f"
            PGPASSWORD=postgres psql -h 127.0.0.1 -U postgres -d postgres -v ON_ERROR_STOP=1 -f "$f"
          done
          echo "‚úÖ Migrations done"

      - name: Build binary (sqlx checks against Postgres on runner)
        env:
          DATABASE_URL: postgres://postgres:postgres@127.0.0.1:5432/postgres
        run: |
          cd lianel/dc/comp-ai-service && cargo build --release
          cp target/release/lianel-comp-ai-service .
          echo "‚úÖ Binary built"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.image-name.outputs.image_name }}
          tags: |
            # Only keep latest tag to save storage (removed branch and sha tags)
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./lianel/dc/comp-ai-service
          file: ./lianel/dc/comp-ai-service/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Make package public automatically
        if: success()
        run: |
          PACKAGE_NAME="${{ steps.image-name.outputs.image_name }}"
          echo "Making package public: $PACKAGE_NAME"
          
          # URL encode the package name (replace / with %2F)
          PACKAGE_NAME_ENCODED=$(echo "$PACKAGE_NAME" | sed 's/\//%2F/g')
          echo "Encoded package name: $PACKAGE_NAME_ENCODED"
          
          # Use GitHub API to make package public
          # Try user endpoint first (for personal accounts)
          if gh api -X PATCH "/user/packages/container/${PACKAGE_NAME_ENCODED}" -f visibility=public 2>&1; then
            echo "‚úÖ Package made public via user endpoint"
          else
            echo "‚ö†Ô∏è  User endpoint failed, trying org endpoint..."
            # Try org endpoint (for organization accounts)
            ORG_NAME=$(echo "$PACKAGE_NAME" | cut -d'/' -f1)
            PACKAGE_PATH=$(echo "$PACKAGE_NAME" | cut -d'/' -f2-)
            PACKAGE_PATH_ENCODED=$(echo "$PACKAGE_PATH" | sed 's/\//%2F/g')
            if gh api -X PATCH "/orgs/${ORG_NAME}/packages/container/${PACKAGE_PATH_ENCODED}" -f visibility=public 2>&1; then
              echo "‚úÖ Package made public via org endpoint"
            else
              echo "‚ö†Ô∏è  Warning: Failed to make package public automatically"
              echo "üí° Please make it public manually: https://github.com/NimaLAN74?tab=packages"
              echo "   Package: $PACKAGE_NAME"
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate Secrets
        run: |
          if [ -z "${{ secrets.REMOTE_HOST }}" ]; then
            echo "‚ùå Error: REMOTE_HOST secret is not set"
            echo "Please add REMOTE_HOST secret in repository settings"
            exit 1
          fi
          if [ -z "${{ secrets.REMOTE_USER }}" ]; then
            echo "‚ùå Error: REMOTE_USER secret is not set"
            echo "Please add REMOTE_USER secret in repository settings"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå Error: SSH_PRIVATE_KEY secret is not set"
            echo "Please add SSH_PRIVATE_KEY secret in repository settings"
            exit 1
          fi
          echo "‚úÖ All required secrets are configured"

      - name: Setup SSH Key
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write SSH key - handle multiline properly
          # Use printf to ensure proper newline handling
          printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Verify key file exists and has content
          if [ ! -s ~/.ssh/deploy_key ]; then
            echo "‚ùå Error: SSH key file is empty or missing"
            echo "Please check that SSH_PRIVATE_KEY secret contains the complete private key"
            exit 1
          fi
          
          # Check file size (should be at least 100 bytes for a valid key)
          KEY_SIZE=$(wc -c < ~/.ssh/deploy_key)
          if [ "$KEY_SIZE" -lt 100 ]; then
            echo "‚ùå Error: SSH key file is too small ($KEY_SIZE bytes)"
            echo "Expected at least 100 bytes for a valid private key"
            echo "First 100 chars: $(head -c 100 ~/.ssh/deploy_key)"
            exit 1
          fi
          
          # Verify key format (must start with -----BEGIN)
          FIRST_LINE=$(head -1 ~/.ssh/deploy_key | tr -d '\r\n' | tr -d '[:space:]')
          if [[ ! "$FIRST_LINE" =~ ^-----BEGIN ]]; then
            echo "‚ùå Error: SSH key format is incorrect"
            echo "First line: '$FIRST_LINE'"
            echo ""
            echo "The SSH_PRIVATE_KEY secret should contain:"
            echo "  - Complete private key starting with: -----BEGIN OPENSSH PRIVATE KEY-----"
            echo "  - Ending with: -----END OPENSSH PRIVATE KEY-----"
            echo "  - All lines in between"
            echo ""
            echo "Current key file preview (first 5 lines):"
            head -5 ~/.ssh/deploy_key
            echo ""
            echo "If you see 'ssh-ed25519' as text, that's wrong - that's the key type, not the key itself"
            exit 1
          fi
          
          # Verify key ends with -----END
          LAST_LINE=$(tail -1 ~/.ssh/deploy_key | tr -d '\r\n' | tr -d '[:space:]')
          if [[ ! "$LAST_LINE" =~ ^-----END ]]; then
            echo "‚ö†Ô∏è  Warning: SSH key might not end correctly"
            echo "Last line: '$LAST_LINE'"
          fi
          
          # Check for common mistakes
          if grep -q "^ssh-ed25519 " ~/.ssh/deploy_key; then
            echo "‚ùå Error: SSH key contains 'ssh-ed25519' as text"
            echo "This looks like a public key, not a private key!"
            echo "The SSH_PRIVATE_KEY secret should contain the PRIVATE key, not the public key"
            echo ""
            echo "To get the private key, run: cat ~/.ssh/id_ed25519_host"
            echo "The private key starts with: -----BEGIN OPENSSH PRIVATE KEY-----"
            exit 1
          fi
          
          # Test key format with ssh-keygen (if available)
          if command -v ssh-keygen >/dev/null 2>&1; then
            if ! ssh-keygen -l -f ~/.ssh/deploy_key >/dev/null 2>&1; then
              echo "‚ö†Ô∏è  Warning: ssh-keygen validation failed (key might be invalid)"
              echo "But continuing anyway..."
            fi
          fi
          
          if [ -n "$REMOTE_HOST" ]; then
            ssh-keyscan -H "$REMOTE_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true
          fi
          
          echo "‚úÖ SSH key ready"
          echo "Key file size: $KEY_SIZE bytes"
          echo "Key file lines: $(wc -l < ~/.ssh/deploy_key) lines"
          
          # Extract and display public key fingerprint for debugging
          if command -v ssh-keygen >/dev/null 2>&1; then
            PUBLIC_KEY_FINGERPRINT=$(ssh-keygen -y -f ~/.ssh/deploy_key 2>/dev/null | ssh-keygen -lf - 2>/dev/null | awk '{print $2}' || echo "N/A")
            echo "Public key fingerprint: $PUBLIC_KEY_FINGERPRINT"
          fi

      - name: Validate Remote Host Configuration
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
        run: |
          echo "Checking REMOTE_HOST configuration..."
          if [ -z "$REMOTE_HOST" ]; then
            echo "‚ùå Error: REMOTE_HOST secret is not set"
            echo "Please add REMOTE_HOST secret in GitHub repository settings:"
            echo "https://github.com/NimaLAN74/hosting-base/settings/secrets/actions"
            exit 1
          fi
          
          # Check for obviously wrong values (but don't fail - just warn)
          if [[ "$REMOTE_HOST" == *"msn.com"* ]] || \
             [[ "$REMOTE_HOST" == *"example.com"* ]] || \
             [[ "$REMOTE_HOST" == *"localhost"* ]] || \
             [[ "$REMOTE_HOST" == "127.0.0.1" ]] || \
             [[ "$REMOTE_HOST" == "0.0.0.0" ]]; then
            echo "‚ö†Ô∏è  Warning: REMOTE_HOST appears to be incorrectly configured"
            echo "Current value contains suspicious pattern: $REMOTE_HOST"
            echo ""
            echo "REMOTE_HOST should be your actual server IP address or hostname"
            echo "Example: 72.60.80.84"
            echo ""
            echo "If this is incorrect, please update it at:"
            echo "https://github.com/NimaLAN74/hosting-base/settings/secrets/actions"
            echo ""
            echo "Continuing anyway - connection will be tested next..."
          else
            echo "‚úÖ REMOTE_HOST configured: $REMOTE_HOST"
          fi

      - name: Deploy to Remote Host
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          IMAGE_TAG="${{ env.REGISTRY }}/${{ steps.image-name.outputs.image_name }}:latest"
          echo "Deploying: $IMAGE_TAG"
          echo "Target: ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_PORT}"
          
          # Retry SSH connection with exponential backoff
          MAX_RETRIES=3
          RETRY_DELAY=5
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i of $MAX_RETRIES..."
            if ssh -i ~/.ssh/deploy_key \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=~/.ssh/known_hosts \
              -o ConnectTimeout=30 \
              -o ServerAliveInterval=10 \
              -o ServerAliveCountMax=3 \
              -p ${REMOTE_PORT} \
              ${REMOTE_USER}@${REMOTE_HOST} \
              "cd /root/hosting-base && git fetch origin && (git pull origin master || { echo 'Pull failed (e.g. local changes), updating only comp-ai files from origin/master'; git checkout origin/master -- lianel/dc/docker-compose.comp-ai.yaml; }) && cd lianel/dc && echo '${GITHUB_TOKEN}' | docker login ghcr.io -u '${{ github.actor }}' --password-stdin && docker compose -f docker-compose.infra.yaml -f docker-compose.comp-ai.yaml pull comp-ai-service && docker compose -f docker-compose.infra.yaml -f docker-compose.comp-ai.yaml up -d comp-ai-service && docker compose -f docker-compose.infra.yaml -f docker-compose.comp-ai.yaml --profile local-model pull ollama && docker compose -f docker-compose.infra.yaml -f docker-compose.comp-ai.yaml --profile local-model up -d ollama && sleep 5 && docker compose -f docker-compose.infra.yaml -f docker-compose.comp-ai.yaml ps comp-ai-service && docker compose -f docker-compose.infra.yaml -f docker-compose.comp-ai.yaml --profile local-model ps ollama && docker logs lianel-comp-ai-service --tail 20 && docker ps --filter name=lianel-ollama --format 'table {{.Names}}\t{{.Status}}'"; then
              echo "‚úÖ Deployment successful"
              exit 0
            else
              EXIT_CODE=$?
              echo "‚ö†Ô∏è  Attempt $i failed with exit code $EXIT_CODE"
              if [ $i -lt $MAX_RETRIES ]; then
                echo "Waiting ${RETRY_DELAY}s before retry..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
              fi
            fi
          done
          
          echo "‚ùå All $MAX_RETRIES connection attempts failed"
          echo "This could be due to:"
          echo "1. Network issues between GitHub Actions and remote host"
          echo "2. Firewall blocking GitHub Actions IP ranges"
          echo "3. SSH service issues on remote host"
          exit 1

      - name: Pull Ollama model (tinyllama)
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
        timeout-minutes: 6
        run: |
          echo "Ensuring Ollama has tinyllama model (idempotent)..."
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o ConnectTimeout=30 \
            -p ${REMOTE_PORT} \
            ${REMOTE_USER}@${REMOTE_HOST} \
            "docker exec lianel-ollama ollama pull tinyllama"
          echo "‚úÖ tinyllama ready"

      - name: Restart Comp-AI to use Ollama
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
        run: |
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o ConnectTimeout=30 \
            -p ${REMOTE_PORT} \
            ${REMOTE_USER}@${REMOTE_HOST} \
            "cd /root/hosting-base/lianel/dc && docker compose -f docker-compose.infra.yaml -f docker-compose.comp-ai.yaml up -d comp-ai-service"
          echo "‚úÖ Comp-AI restarted with Ollama defaults"

      - name: Run comp_ai migrations on production DB
        continue-on-error: true
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
        run: |
          # Use postgres user for DDL; script reads POSTGRES_PASSWORD from server .env
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o ConnectTimeout=30 \
            -p ${REMOTE_PORT} \
            ${REMOTE_USER}@${REMOTE_HOST} \
            "cd /root/hosting-base && git fetch origin && git checkout origin/master -- lianel/dc/scripts/deployment/run-comp-ai-migrations.sh lianel/dc/database/migrations/009_create_comp_ai_schema.sql lianel/dc/database/migrations/010_comp_ai_controls_evidence.sql lianel/dc/database/migrations/011_comp_ai_seed_soc2.sql && cd lianel/dc && COMP_AI_MIGRATION_USER=postgres bash scripts/deployment/run-comp-ai-migrations.sh"
          echo "‚úÖ comp_ai migrations (009, 010, 011) applied"

      - name: Verify Deployment
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_PORT: ${{ secrets.REMOTE_PORT || '22' }}
        run: |
          sleep 10
          echo "Checking Comp-AI service..."
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o ConnectTimeout=30 \
            -p ${REMOTE_PORT} \
            ${REMOTE_USER}@${REMOTE_HOST} \
            "docker ps --filter name=lianel-comp-ai-service --format '{{.Names}} {{.Status}}'"
          
          echo "Checking Ollama container..."
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o ConnectTimeout=30 \
            -p ${REMOTE_PORT} \
            ${REMOTE_USER}@${REMOTE_HOST} \
            "docker ps --filter name=lianel-ollama --format '{{.Names}} {{.Status}}'"
          
          echo "Running Comp-AI health check..."
          if ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o ConnectTimeout=30 \
            -p ${REMOTE_PORT} \
            ${REMOTE_USER}@${REMOTE_HOST} \
            "docker exec lianel-comp-ai-service curl -f http://localhost:3002/health"; then
            echo "‚úÖ Comp AI Service health check passed"
          else
            echo "‚ùå Comp-AI health check failed. Showing container logs:"
            ssh -i ~/.ssh/deploy_key \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=~/.ssh/known_hosts \
              -o ConnectTimeout=30 \
              -p ${REMOTE_PORT} \
              ${REMOTE_USER}@${REMOTE_HOST} \
              "docker logs lianel-comp-ai-service --tail 30"
            exit 1
          fi
          
          echo "Checking Ollama API..."
          if ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o ConnectTimeout=30 \
            -p ${REMOTE_PORT} \
            ${REMOTE_USER}@${REMOTE_HOST} \
            "docker exec lianel-ollama curl -sf http://localhost:11434/api/tags >/dev/null || docker exec lianel-ollama curl -sf http://localhost:11434/"; then
            echo "‚úÖ Ollama container is up and responding"
          else
            echo "‚ö†Ô∏è  Ollama container may still be starting (check docker logs lianel-ollama on server)"
          fi

      - name: Deployment Summary
        run: |
          echo "## üöÄ Comp AI Service Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: \`${{ env.REGISTRY }}/${{ steps.image-name.outputs.image_name }}:latest\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Platform**: linux/amd64" >> $GITHUB_STEP_SUMMARY
          echo "- **Language**: Rust" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed to**: \`${{ secrets.REMOTE_HOST }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Storage Optimized**: ‚úÖ No artifacts, direct registry pull" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ‚úÖ Success" >> $GITHUB_STEP_SUMMARY
